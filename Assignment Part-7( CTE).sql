#Q5) Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the actor and film_actor tables.
with ActorFilmCount as (
    select 
        a.actor_id,
        concat(a.first_name, ' ', a.last_name) as actor_name,
        count(fa.film_id) as film_count
    from actor a
    join film_actor fa 
        on a.actor_id = fa.actor_id
    group by a.actor_id, actor_name
)

-- Step 2: Select from the CTE
select actor_name, film_count
from ActorFilmCount
order by film_count desc;

#Q6). CTE with Joins:
 -- a. Create a CTE that combines information from the film and language tables to display the film title, 
 -- language name, and rental rate.
 
 with FilmLanguage as (
    select 
        f.film_id,
        f.title,
        l.name as language_name,
        f.rental_rate
    from film f
    join language l 
        on f.language_id = l.language_id
)
select title, language_name, rental_rate
from FilmLanguage
order by language_name, title;



#Q7)CTE for Aggregation:
 -- a. Write a query using a CTE to find the total revenue generated by each customer (sum of payments) 
 -- from the customer and payment tables.
 with CustomerRevenue as (
    select 
        c.customer_id,
        concat(c.first_name, ' ', c.last_name) as full_name,
        sum(p.amount) as total_revenue
    from customer c
    join payment p 
        on c.customer_id = p.customer_id
    group by c.customer_id, c.first_name, c.last_name
)
select customer_id, full_name, total_revenue
from CustomerRevenue
order by total_revenue desc;


#Q8)CTE with Window Functions:
 -- a. Utilize a CTE with a window function to rank films based on their rental duration from the film table.
 
 with FilmRanking as (
    select 
        film_id,
        title,
        rental_duration,
        rank() over (order by rental_duration desc) as duration_rank
    from film
)
select film_id, title, rental_duration, duration_rank
from FilmRanking
order by duration_rank;

#Q9)CTE and Filtering:
 -- a. Create a CTE to list customers who have made more than two rentals, and then join this CTE with the 
 -- customer table to retrieve additional customer details
 
 with CustomerRentals as (
    select 
        customer_id,
        count(rental_id) as total_rentals
    from rental
    group by customer_id
    having count(rental_id) > 2
)
select 
    c.customer_id,
    c.first_name,
    c.last_name,
    cr.total_rentals
from CustomerRentals cr
join customer c 
    on cr.customer_id = c.customer_id
order by cr.total_rentals desc;

#Q10)CTE for Date Calculations:
 -- a. Write a query using a CTE to find the total number of rentals made each month, considering the 
-- rental_date from the rental table

with MonthlyRentals as (
    select 
        extract(year from rental_date) as rental_year,
        extract(month from rental_date) as rental_month,
        count(rental_id) as total_rentals
    from rental
    group by extract(year from rental_date), extract(month from rental_date)
)
select 
    rental_year,
    rental_month,
    total_rentals
from MonthlyRentals
order by rental_year, rental_month;

#Q11)TE and Self-Join:
-- a. Create a CTE to generate a report showing pairs of actors who have appeared in the same film 
-- together, using the film_actor table.
with ActorPairs as (
    select 
        fa1.film_id,
        fa1.actor_id as actor1,
        fa2.actor_id as actor2
    from film_actor fa1
    join film_actor fa2
        on fa1.film_id = fa2.film_id
       and fa1.actor_id < fa2.actor_id   -- avoid duplicates and self-pairs
)
select 
    ap.film_id,
    concat(a1.first_name, ' ', a1.last_name) as actor1_name,
    concat(a2.first_name, ' ', a2.last_name) as actor2_name
from ActorPairs ap
join actor a1 on ap.actor1 = a1.actor_id
join actor a2 on ap.actor2 = a2.actor_id
order by ap.film_id, actor1_name, actor2_name;

#Q12)CTE for Recursive Search:
-- a. Implement a recursive CTE to find all employees in the staff table who report to a specific manager, 
-- considering the reports_to column
with recursive StaffHierarchy as (
    -- Anchor member: start with the manager
    select 
        staff_id,
        first_name,
        last_name,
        reports_to
    from staff
    where staff_id = 1   -- replace 1 with the manager's staff_id

    union all

    -- Recursive member: find staff reporting to the ones already found
    select 
        s.staff_id,
        s.first_name,
        s.last_name,
        s.reports_to
    from staff s
    join StaffHierarchy sh 
        on s.reports_to = sh.staff_id
)
select staff_id, first_name, last_name, reports_to
from StaffHierarchy
where staff_id <> 1  -- exclude the manager themselves
order by staff_id;